// the io module implements functions for writing to and
// reading from file handlers and streams

conv mod = use "str/conv.lim";
mkr  mod = use "str/mkr.lim";
rt   mod = use "std/rt.lim";

// runtime wrappers for the std handles
pub stdin  u32 = use "rt.stdin";
pub stdout u32 = use "rt.stdout";
pub stderr u32 = use "rt.stderr";

io_read      efx = use stdin;
io_write_out efx = use stdout;
io_write_err efx = use stderr;
io_write     efx = io_write_out & io_write_err;

// prints `data` to stdout
// if data has length of zero, no printing occurs
// returns `error` if any error occurs during printing
pub fn print(data str) !unit = rt & io_write {
    fprint(stdout, data)?;
};

// prints `data` followed by a line feed to stdout
// if data has length of zero, no printing occurs
// returns `error` if any error occurs during printing
pub fn println(data str) !unit = rt & io_write {
    fprintln(stdout, data)?;
};

// prints `data` followed by a line feed to stderr and
// halts the program execution with exit code of 1 
pub fn panic(data str) !void = rt & io_write {
    reportln(data)!;
};

// prints `data` to stderr
// if data has length of zero, no printing occurs
// returns `error` if any error occurs during printing
pub fn report(data str) !unit = rt & io_write {
    fprint(stderr, data)?;
};

// prints `data` followed by a line feed to stderr
// if data has length of zero, no printing occurs
// returns `error` if any error occurs during printing
pub fn reportln(data str) !unit = rt & io_write {
    fprintln(stderr, data)?;
};

// prints `data` followed by a line feed to the given file
// handle
// if data has length of zero, no printing occurs
// returns `error` if any error occurs during printing
pub fn fprintln(handle u32, data str) !unit = rt {
    fprint(handle, data)?; fprint(handle, "\n")?;
};

// prints `data` to the given file handle
// if data has length of zero, no printing occurs
// returns `error` if any error occurs during printing
pub fn fprint(handle u32, data str) !unit = rt {
    // empty data
    if #data == 0 { return; };
    // allocate mutable copy of data
    new dup | #data + 16 {
        let mut dummy = new ? data @ dup;
        if code = rt::write(handle, dummy []u8); code < 0 {
            return error;
        };
    }?;
};

// buffered IO stream type
// requires to be instantiated and dynamically allocated
type stream = record {
    handle u32;
    mut bufptr u64;
    mut buffer []u8;
};

init efx = mut mem;
io_stream efx = mut stream;
buff_write efx = mut []u8;

// instantiates a new stream of internal buffer of size
// `buff_sz` that prints to `handle`
// returns `nil` if the buffer allocation at the given
// arena fails
pub fn new_stream(handle u32, buff_sz u64, mut a mem) !stream @ a = init {
    return stream {
        buffer = new ? [buff_sz; 0...] @ a,
        bufptr = 0,
        handle = handle,
    };
};

// prints `data` to given stream's handle
// data is buffered up to `st.buffer`'s length and then
// it's flushed. once it reaches max capacity. if given
// data does not fit within the current buffer, the stream
// is automatically flushed and the data imediatly printed
// if data is empty, no writing or flushing occurs
pub fn stprint(mut st stream, data str) !unit = rt & mkr & io_stream {
    // data fits within buffer
    if #data > 0 && #data + st.bufptr < #st.buffer {
        // write to buffer
        mkr::write_to(st.buffer[st.bufptr .. #st.buffer]!, data)?;
        st.bufptr = st.bufptr + #data;
        // check if it's time to flush
        if st.bufptr == #st.buffer {
            stflush(st)?;
        };
    // flush out buffer and print given data
    } else if #data > 0 {
        stflush(st)?;
        fprint(st.handle, data)?;
    };
};

// empties out the given stream's buffer and resets it to
// zero
// if the buffer is empty, no flushing occurs
pub fn stflush(mut st stream) !unit = rt & io_stream {
    // empty buffer
    if st.bufptr == 0 { return; };
    // write to handle
    fprint(st.handle, st.buffer[0..st.bufptr]! str)?;
    // clear buffer
    for mut itm, idx .. st.buffer[0..st.bufptr]! {
        itm = 0;
    };
    // reset buffer pointer
    st.bufptr = 0;
};

// reads from stdin and places in the given buffer
// returns `error` oif any error occurs during memory reading
// returns `nil` if buffer is too small
pub fn read_to(mut buffer []u8) !u64 = rt & io_read & buff_write {
    return fread_to(stdin, buffer)?;
};

// reads from a given handle and places in the given buffer
pub fn fread_to(handle u32, mut buffer []u8) !u64 = rt & buff_write {
    if code = rt::read(handle, buffer); code < 0 {
        return error;
    } else {
        return code u32;
    };
};
